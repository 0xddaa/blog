title: 0CTF 2015 Exploit 250 FlagGenerator
date:
category: pwn
tags: 0CTF, bof
slug: 0ctf_exploit_250_flaggenerator

這題的名稱叫 *FlagGenerator*  
可惜沒辦法生出其他題的 flag ... XD  
* * *

執行程式後看到 menu 長這樣:

> == 0ops Flag Generator ==  
> 1. Input Flag  
> 2. Uppercase  
> 3. Lowercase  
> 4. Leetify  
> 5. Add Prefix  
> 6. Output Flag  
> 7. Exit  
> =========================  
> Your choice:  

打開 **ida pro** 快速檢查  
flag 的長度限制為 256 byte  
但是 *Leetify* 的功能會造成 bof  
原因是 *Leetify* 會將字串內的 *H* 或是 *h* 字元取代成 *1-1*  
所以只要送包含夠多的 *H* 或是 *h* 字串  
就會超出 256 byte 了  
pseudo code:  

```
void Leetify(char *flag)
{
    char *c = flag;
    char buf[256];
    for (c = flag; c != NULL; c++) {
        switch(c) {
            case 'H':
            case 'h':
                /* do leetify on buf*/
                break;
        }
    }
    buf[end] = '\0';
    strcpy(flag, buf);
    return;
}
```

雖然這題的 bof 發生在 stack 上  
但是有 **stack guard** 的檢查  
沒辦法直接改 ret addr 去控制 eip  
但是 return 前的 `strcpy()` 讓我們有機會繞過保護  
由於傳入的參數 `flag` 也是在 stack 上  
發生 bof 之後可以改掉參數的內容  
這樣 `strcpy()` 就變成可以任意寫值的漏洞  
我們可以將 `__stack_chk_fail()` 在 GOT 上的值指向 `ret`  
程式就不會因為 *detect overflow* 而結束  

剩下就是寫 exploit 了  
由於這題有使用到 `puts()`  
所以可以透過 `puts()` 去 leak 出 **libc base**  
但是因為改 `__stack_chk_fail()` GOT 的同時也把其他 function 的 GOT 改壞了  
就沒辦法跳回 `main()` 再觸發一次 bof  
所以改成 return 到 `readn()` 將新的 rop payload 寫到 **bss** 段  
最後透過 `leave` 將 stack 給換到 bss 段繼續我們的 rop attack  
就可以成功拿到 shell 了 ~  

exploit: [flaggen.py]({filename}/exp/flaggen.py)  

flag: `0ctf{delicious_stack_cookie_generates_flag}`  
