title: VolgaCTF 2014 Exploit 100 Exploit100 
date: 2014-3-31 0:48
category: pwn
tags: OtherCTF
slug: volgactf_2014_exploit_100_exploit100

突然被揪來玩的一次ctf XDD  
結果說好的養身又沒了 OTZ  
這次想嘗試解比較難的題目  
結果就是 very not work ....  
希望下次能解些分數比較高的題目 QQ  
* * *

一樣先看題目環境:   
> The password consists of 12 printable characters  
> 111111111111  
> 344  

```
while(1){
  ...
  if ( v5 == 12 )
      break;
    v7 = rand() % 1000;
    for ( j = 0; j < v5; ++j )
    {
      for ( k = 1; (unsigned int)k <= 0xDEADBEEE; ++k )
        v7 = k ^ (k + v7);
    }
    sprintf(&s, "%x\n", v7);
    write(fd, &s, strlen(&s));
  }
  write(fd, v10, strlen(v10));

```

這題會接受 12 個字元  
然後跟 *password.txt* 比對  
如果相同就會把 flag 印出來  
如果不同則會檢查有幾個字元是相同  
把結果存在變數 `v5`  
接著對密碼做 v5 次的 xor 運算 然後把結果回傳  
比如說 答對兩個字元就會做兩次計算  
全部答錯則一次都不計算  

想了一陣子突然發現這題根本不用知道運算的結果  
因為只要不是全部答錯就會花上好一段時間去算  
可以用是不是馬上回傳結果來判斷 `input == password`  
用的技巧跟 **SQli** 猜密碼差不多  
先找出一個不包含在 password 的字元  
接著逐步嘗試每個位置  
ex : `a11111111111`  
如果 a 包含在 password 就會花一段時間去計算  
反之則馬上有結果  
最後試出來的結果是 `S@nd_will2z0`  
p.s 這題最難的地方是題目環境一直掛掉  

flag : `Time_works_for_you`  
